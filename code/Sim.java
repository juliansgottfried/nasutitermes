/*
Description: reads 6 arguments from command line. First is a string, the name of the txt file map
to run the simulation on. This txt file must be in the same directory as the code. Second is an
integer, the number of duplicate runs of the simulation to perform. Third is an integer, the value
of ERT. Fourth is an integer, the value of C. Fifth is an integer, the number of time steps for
each simulation run. Sixth and last is a boolean, whether or not to animate the simulation.

If animate mode is on, code will display map of red, circular spines on a black background. Termites
of yellow squares will move around and consume spines. Spines under active consumption are pink.
Consumed spines are erased. Termites leave orange trails behind them, which are erased once the
trails become inactive. The simulation stops when all the spines are consumed or when time is over.

Once the simulation is over, the code will print to standard output the number of spines, the average
number of spines consumed over the simulation runs, and the average proportion of spines consumed
over the simulation runs.

Author: Julian Gottfried
 */

import net.sf.javaml.core.kdtree.KDTree;

import java.util.Stack;

public class Sim {

    // number of time steps in run
    private int TIME;
    // exploration rate of termites – how many time steps pass between new termite groups made
    private int ERT;
    // consumption time – how many time steps before generating points expire
    private int CONSUMPTION;

    // k-d tree to keep track of locations of spines that have yet to be consumed
    private KDTree uneaten;

    // k-d tree to keep track of locations of all spines – only used in animation mode
    private KDTree all;

    // custom data structure to keep track of spines that are termite generating points
    private SpineTree active;

    // resizing array to keep track of the number of discrete branches leading from the root spine
    // to consumed spines for all consumed spines
    ResizingArray<Double> branchNum;

    // data being recorded
    StringBuilder info;

    // length of map
    private double n;

    // number of spines
    int totalCount;

    // number of spines that have been eaten
    int eatenCount;

    // number of spines eaten in previous time step
    int oldEatenCount;

    // first termite in linked list of active termite groups
    private Termites first;

    // switch to turn animation mode on or off
    private boolean animate;

    public Sim(int ERT, int CONSUMPTION, int TIME, boolean animate) {
        final int DIMENSIONS = 2;
        this.ERT = ERT;
        this.CONSUMPTION = CONSUMPTION;
        this.TIME = TIME;
        uneaten = new KDTree(DIMENSIONS);
        this.animate = animate;
        if (animate) all = new KDTree(DIMENSIONS);
        active = new SpineTree(CONSUMPTION);
        totalCount = 0;
        eatenCount = 0;
        oldEatenCount = 0;
        first = null;
        branchNum = new ResizingArray<>();
        info = new StringBuilder();
    }

    // read in user-provided map
    public void read(String filename) {
        filename = System.getProperty("user.dir") + "/" + filename;
        In file = new In(filename);
        double x;
        double y;
        n = file.readDouble();
        if (animate) setup();
        while (!file.isEmpty()) {
            x = Math.floor(file.readDouble());
            y = Math.floor(file.readDouble());
            double[] coords = new double[]{x, y};
            // map files are generated by user mouse click inputs, so there are repeated values.
            // Repeated spines are avoided by searching in k-d tree for presence of spine before
            // inserting.
            if (uneaten.search(coords) == null) {
                Spine spine = new Spine(coords);
                // if spine being inserted is the first, make it the root, and treat it as active.
                if (totalCount == 0) {
                    if (animate) drawSpawn(coords);
                    // root has no parent and infinite life span, because it's treated as a permanent
                    // termite generating point
                    active.insert(null, spine, Double.POSITIVE_INFINITY);
                    // add branch number information
                    branchNum.appendNum(spine.numBranch);
                    eatenCount++;
                } else {
                    // insert into k-d tree of uneaten spines
                    if (animate) drawSpine(coords);
                    uneaten.insert(coords, spine);
                }
                if (animate) all.insert(coords, spine);
                totalCount++;
            }
        }
        if (animate) StdDraw.show();
    }

    // reads in a hard-coded map that was randomly-generated by BuildRandom.java. Base for analysis
    // runs.
    public void readData() {
        n = 50;
        int[] data = new int[]
                {25, 18, 49, 10, 49, 0, 49, 37, 7,
                        0, 32, 11, 29, 34, 48, 4, 20, 13, 42,
                        12, 31, 45, 18, 18, 27, 23, 21, 27, 21,
                        1, 20, 41, 12, 47, 45, 2, 16, 46, 25,
                        30, 29, 20, 33, 33, 40, 33, 32, 16, 18,
                        13, 21, 45, 26, 17, 42, 19, 7, 9, 30,
                        24, 20, 13, 11, 27, 20, 39, 32, 30, 20,
                        36, 28, 17, 10, 21, 7, 11, 3, 29, 11,
                        13, 42, 28, 33, 7, 12, 1, 37, 44, 12,
                        22, 13, 7, 41, 40, 38, 8, 28, 21, 20,
                        12, 29, 47, 40, 17, 20, 35, 12, 18,
                        41, 44, 8, 19, 0, 7, 29, 11, 34, 6,
                        21, 42, 40, 21, 26, 37, 32, 36, 45, 12,
                        23, 29, 34, 17, 17, 30, 17, 35, 45, 33,
                        16, 40, 44, 10, 15, 34, 46, 11, 0, 38,
                        9, 42, 16, 43, 21, 23, 16, 10, 0, 27,
                        24, 21, 25, 46, 9, 32, 7, 31, 1, 2,
                        37, 27, 7, 27, 6, 48, 12, 26, 44, 42,
                        24, 19};
        if (animate) setup();
        for (int i = 0; i < 180; i = i + 2) {
            double[] coords = new double[]{data[i], data[i + 1]};
            if (uneaten.search(coords) == null) {
                Spine spine = new Spine(coords);
                if (totalCount == 0) {
                    if (animate) drawSpawn(coords);
                    active.insert(null, spine, Double.POSITIVE_INFINITY);
                    branchNum.appendNum(spine.numBranch);
                    eatenCount++;
                } else {
                    if (animate) drawSpine(coords);
                    uneaten.insert(coords, spine);
                }
                if (animate) all.insert(coords, spine);
                totalCount++;
            }
        }
        if (animate) StdDraw.show();
    }

    // run simulation
    public void run() {
        int i;
        // iterate through time steps
        for (i = 0; i < TIME; i++) {
            // every ERT time steps, make a new termite group
            if (i % ERT == 0) {
                // termite starting point is a random spine currently under consumption
                Termites termites = new Termites(active.sample());
                // insert termite in linked list of termites
                first = termites.insert(first);
                if (animate) drawTermite(termites.coords);
            }
            // remove all expired spines from tree of active spines
            Stack<Spine> trash = active.delete(i);
            // if animation mode, erase spines and remove k-d tree of all spines
            if (animate) {
                while (!trash.isEmpty()) {
                    Spine pop = trash.pop();
                    active.erase(pop);
                    all.delete(pop.coords);
                }
            }
            // iterate through all termites
            Termites iterator = first;
            while (iterator != null) {
                // if spine that termites originated from has expired while termites have been
                // exploring, remove termite exploration party
                if (iterator.progenitor.removed == 1) {
                    first = iterator.remove(first);
                    if (animate) erase(iterator.coords);
                    iterator = iterator.next;
                } // move termites and go to next; pass current time step as the time
                else iterator = move(iterator, i);
            }
            if (animate) StdDraw.show();
            // if new spines have been consumed since previous time step, or if all spines have been
            // eaten, or if maximum time step has been reached, then add data to data recorder
            if (oldEatenCount != eatenCount
                    || eatenCount == totalCount
                    || i == TIME - 1) {
                // ERT
                info.append(ERT).append(",");
                // C
                info.append(CONSUMPTION).append(",");
                // time step
                info.append(i).append(",");
                // proportion of spines eaten
                info.append(eatenCount / (double) totalCount).append(",");
                // mean and sd of consumed spine branch numbers
                info.append(branchNum.stats()).append("\n");
                oldEatenCount = eatenCount;
            }
            // end simulation if all spines eaten
            if (eatenCount == totalCount) {
                break;
            }
        }
    }

    // move single termite group; takes current time step as the time
    public Termites move(Termites termites, int time) {
        if (animate) erase(termites.coords);
        // move termites
        termites.walk(n);
        // if beyond y-axis bounds, remove termites
        if (termites.coords[1] < 0 || termites.coords[1] > n - 1) {
            first = termites.remove(first);
        } else {
            if (animate) drawTermite(termites.coords);
            Spine match = (Spine) uneaten.search(termites.coords);
            // if termites have found an uneaten spine, and if coin flip decision is affirmative,
            // consume spine
            if (match != null && StdRandom.uniformDouble() > 0.5) consume(termites, match, time);
        }
        // return next termite in linked list
        return termites.next;
    }

    // consume spine
    public void consume(Termites termites, Spine spine, int time) {
        // delete spine from k-d tree of uneaten spines
        uneaten.delete(spine.coords);
        // insert spine into active tree. Parent of spine is the spine termites came from. Starting
        // time is the current time step.
        active.insert(termites.progenitor, spine, time);
        // add branch number information
        branchNum.appendNum(spine.numBranch);
        if (animate) active.draw(spine);
        if (animate) drawSpawn(termites.coords);
        // remove termites from linked list, because no longer exploring
        first = termites.remove(first);
        if (animate) erase(termites.coords);
        eatenCount++;
    }

    // returns csv of ERT, C, time step, proportion eaten, branch number mean, branch number sd
    public String toString() {
        return info.toString();
    }

    // draws black n by n map
    public void setup() {
        StdDraw.clear();
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.setXscale(0, n);
        StdDraw.setYscale(0, n);
        StdDraw.filledSquare(n / 2, n / 2, n / 2);
        StdDraw.enableDoubleBuffering();
    }

    // draws circular red spine
    public void drawSpine(double[] coords) {
        StdDraw.setPenColor(StdDraw.RED);
        StdDraw.filledCircle(coords[0] + 0.5, coords[1] - 1.5, 0.5);
    }

    // draws circular pink generating spine
    public void drawSpawn(double[] coords) {
        StdDraw.setPenColor(StdDraw.PINK);
        StdDraw.filledCircle(coords[0] + 0.5, coords[1] - 1.5, 0.5);
    }

    // if termite not overlapping with spine, draws square yellow termite
    public void drawTermite(double[] coords) {
        if (all.search(coords) != null)
            return;
        StdDraw.setPenColor(StdDraw.YELLOW);
        StdDraw.filledSquare(coords[0] + 0.5, coords[1] - 1.5, 0.5);
    }

    // if termite not overlapping with spine, erases termite
    public void erase(double[] coords) {
        if (all.search(coords) != null)
            return;
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.filledSquare(coords[0] + 0.5, coords[1] - 1.5, 0.5);
    }

    public static void main(String[] args) {
        String filename = args[0];
        final int RUNS = Integer.parseInt(args[1]);
        final int ERT = Integer.parseInt(args[2]);
        final int C = Integer.parseInt(args[3]);
        final int TIME = Integer.parseInt(args[4]);
        final boolean animate = Boolean.parseBoolean(args[5]);
        // Set random seed for simulation runs
        StdRandom.setSeed(System.currentTimeMillis());
        double eaten = 0;
        double total = 0;
        for (int i = 0; i < RUNS; i++) {
            Sim sim = new Sim(ERT, C, TIME, animate);
            sim.read(filename);
            sim.run();
            if (i == 0) total = sim.totalCount;
            eaten += sim.eatenCount;
        }
        StdOut.printf("Total number of spines: %f\n", total);
        StdOut.printf("Average number of spines eaten: %f\n", eaten / RUNS);
        StdOut.printf("Average proportion of spines eaten: %f\n", eaten / (total * RUNS));
    }
}
